---
title: Datora darbības principi
---

# Apzīmējumi un Modeļi

````attention-recommendation {label: "Atceries"}

2 pakāpē 10 ir 1024. To pieraksta tā:
```latex
2^{10} = 2 2  \cdot 2  \cdot 2  \cdot 2  \cdot 2  \cdot 2  \cdot 2  \cdot 2  \cdot 2 = 1024
```
````

Datori darbojas ar binārā koda skaitļiem un desmitnieku sistēmas skaitļus aprēķiniem vispirms pārvērš binārajā kodā. Piemēram, 5 desmitnieku sistēmā binārajā sistēmā būs 
```latex
101 = 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 
```

bet 7 būs 

```latex
111 = 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0
```

Tātad, binārajā sistēmā 5 ir 101 un 7 ir 111.

Binārie skaitļi sastāv tikai no 1 un 0, kas elektroniski nozīmē “strāva plūst” vai “strāva neplūst” (lai gan citi apzīmējumi, piemēram, patiess/nepatiess vai ieslēgts/izslēgts, ir vienlīdz derīgi). Šādu skaitļu saskaitīšanu, reizināšanu u.c. var viegli īstenot ar elektroniskajiem slēdžiem un tā būvē skaitļošanas procesorus.

Skaitļošanā šos 1 un 0 sauc par **bitiem**. Vienu skaitli parasti kopā veido 8 biti jeb 32=28 un to sauc par **baitu**.
Baits satur tikai tik daudz informācijas, lai izveidotu vienu mazo burtu vai ciparu. Ar bināro kodu, jebkuru ciparu, burtu, vārdu vai pikseli attēlā var aizstāt ar baitu virkni.

**Peldošā komata un veseli skaitļi.** Skaitļošanā peldošā komata skaitlis ir reprezentācija reālam skaitlim. Peldošā komata skaitļi tiek izmantoti, lai attēlotu plašu vērtību diapazonu, arī ļoti lielus vai ļoti mazus skaitļus, un tie ir datora aritmētikas pamatdaļa. Piemēram, skaitlis 2001 kļūs par `:latex: {src: "2,001 * 10^3"}`, bet skaitlis  `:latex: {src: "0,002001"}` kļūs par  `:latex: {src: "2,001 * 10^{-3}"}`. Tas nozīmē, ka šādā veidā varam jebkuru skaitli pārvērst zīmīgajos ciparos un 10 pakāpēs.

Vesels skaitlis ir skaitlis, kas var būt naturāls skaitlis (pozitīvs jeb lielāks par nulli), naturālo skaitļu pretējais skaitlis (negatīvs jeb mazāks par nulli) vai nulle. Veselo skaitļu ir bezgalīgi daudz, neeksistē lielākais un mazākais veselais skaitlis. Tos izmanto dažādās lietojumprogrammās, piemēram, skaitīšanā, aritmētiskās operācijās un datu glabāšanā. Veseli skaitļi parasti tiek attēloti, izmantojot fiksētu bitu skaitu, kas nosaka attēlojamo vērtību diapazonu. Piemēram, 32 bitu (4x8 biti) vesels skaitlis var attēlot vērtības no -2 147 483 648 līdz 2 147 483 647. Tas ir standarta precizitātes skaitlis, bet superdatoros var būt speciāliem aprēķiniem uzmantoti arī 64 bitu skaitļi un tie ir divkāršas precizitātes (angl. _double-precision_).


## Datora Modelis

:include-image: pix/hpc-datora-modelis-w.png {anchorId: "datora-modelis", collapsed: false,  align:"center", scale: 0.7, title: "Datora Modelis - LV/EN", desktopOnly: true}

:include-image: pix/hpc-datora-modelis.png {anchorId: "datora-modelis", collapsed: false,  align:"center", fit: true, title: "Datora Modelis - LV", mobileOnly: true}


**Mūra likums un takts frekvence.** Kad sāka attīstīties integrālo shēmu ražošanas, Intel firmas dibinātājs Gordons Mūrs (_Gordon Moore_) paredzēja, ka tranzistoru izmēri pakāpeniski samazināsies un tranzistoru skaits vienā mikroshēmā pieaugs.

Mūra likums tika formulēts 1965. gada publikācijā un tas noteica, ka ik pēc diviem gadiem tranzistoru skaits mikroshēmā divkāršosies. Tas tāpēc, ka attīstās tehnoloģija un var izveidot arvien mazākus tranzistorus. Līdz par mūsdienām šis likums joprojām darbojas.
Tas nozīmē logaritmisku pieaugumu. Pēc 2 gadiem 2 reizes vairāk tranzistoru, pēc 4 gadiem jau 2x2=4 reizes, bet pēc 6 gadiem jau 2x2x2=8 reizes vairāk un tā tālāk.

Ja pirmajā Intel 4004 CPU (1971) bija tikai 2300 tranzistori 10 mm lieli, tad tagad jau ir mikroshēmas ar ~ 30 miljardiem tranzistoru, kas ir tikai 3 nm lieli.
Samazinot tranzistoru izmērus varēja palielināt arī CPU takts frekvenci. Ja Intel 4004 takts frekvence bija tikai 750 kHz, tad ap 2005. gadu sasniegts maksimums daži GHz un turpmākais palielinājums nebūs. Ar vēl augstāku takts frekvenci strauji pieaug izdevumi mikroshēmas dzesēšanai.

**Frekvence** ir ciklu vai svārstību skaita rādītājs laika vienībā. To izsaka tādās mērvienībās kā herci (Hz), kas apzīmē vienu ciklu sekundē. Frekvence ir svarīgs jēdziens dažādās jomās, tostarp fizikā, inženierzinātnēs un matemātikā. To lieto, lai aprakstītu ātrumu, kādā sistēma vai process svārstās vai vibrē. Skaņas kontekstā frekvence tiek izmantota, lai aprakstītu skaņas augstumu, kur augstākas frekvences rada augstākas skaņas un zemākas frekvences rada zemākas skaņas. Datoru kontekstā frekvence attiecas uz centrālā procesora takts frekvenci, kas ir mērījums, cik ciklu sekundē procesors var izpildīt.


```spoiler {title: "Pašpārbaudes Jautājums"}
1. Kura no šīm ir augstākā frekvence?

+ Kilohercs
+ Megahercs
+ Gigahercs
+ **Terahercs**
```

## Elementārs HPC Mezgla Modelis

> "MEZGLS" (eng. *Node*) ir funkcionāls iekārtu apvienojums,
kas nodrošina gan skaitļošanu, gan datu īstermiņa uzglabāšanu.

:include-image: pix/hpc-node-model-en-lv-w.png {title: "HPC mezgls / HPC node", fit: true, align: "center",  desktopOnly: true }


## HPC Klastera Modelis no Datu Skatu Punkta

> Kas ir HPC klasteris / HPC datoru kopa

:include-image: pix/hpc-cluster-lv-en-w.png {title: "HPC klasteris / HPC datoru kopa", fit: true, align: "left",  desktopOnly: true }

:include-image: pix/hpc-cluster-en-mob.png {title: "HPC cluster model", fit: true, align: "left",  mobileOnly: true }

:include-image: pix/hpc-cluster-lv-mob.png {title: "HPC klastera modelis / HPC datoru kopa", fit: true, align: "left",  mobileOnly: true }

<!-- <img src="https://github.com/viktorszagorskis/hpc-pamati/blob/main/pix/HPC-KLASTERA-MODELIS.png?raw=true" alt="HPC Klastera Modelis" width="800"/> -->

## HPC Klatera Anatomija


:include-image: pix/hpc-cluster-anatomy-lv-w.png {title: "HPC klastera Anatomija - LV", scale: 0.8, align: "center",  desktopOnly: true }

:include-image: pix/hpc-cluster-anatomy-lv-mob.png {title: "HPC klastera Anatomija - LV", fit: true, align: "left",  mobileOnly: true }

:include-image: pix/hpc-cluster-anatomy-en-w.png {title: "HPC klastera Anatomija - EN", scale: 0.8, align: "center",  desktopOnly: false }



>  Jautajumi seko ...


- Kas ir [RAM](https://lv.wikipedia.org/wiki/Br%C4%ABvpiek%C4%BCuves_atmi%C5%86a) ?
- Kas ir [CACHE](https://en.wikipedia.org/wiki/CPU_cache) ?
- Kas ir SDD?
- Kas ir SHARED MEMORY?
- Kas ir [NAS](https://www.seagate.com/gb/en/blog/what-is-nas-master-ti) ?



### Par Sīkatmiņu jeb Kešatmiņu (eng. CACHE) (LV versija)

> Procesora kešatmiņa (angļu: cache) ir atmiņas veids, ko izmanto datora procesors, lai samazinātu vidējo piekļūšanas laiku operatīvajai atmiņai (RAM). Kešatmiņa jeb kešs ir maza, ātra atmiņa, kas glabā tās datu atmiņu kopijas no galvenās atmiņas, kuras datorprogrammas izmanto visbiežāk. Kamēr vien lielākā daļa piekļuves notiks kešam, nevis galvenajai atmiņai, atmiņas piekļūšanas vidējais latentums (latency) būs tuvāks keša latentumam, nevis galvenās atmiņas latentumam, kas vairumā gadījumu nodrošina būtisku aparatūras darbības paātrināšanos.

> Kad procesors vēlas nolasīt vai ierakstīt galvenajā atmiņā, tas vispirms pārbauda, vai šī atmiņas kopija jau neatrodas kešā. To panāk, salīdzinot atmiņas atrašanās adresi ar visiem tagiem kešā, kas varētu saturēt šo adresi. Ja procesors atrod, ka atmiņas kopija ir kešā, saka, ka ir noticis keša trāpījums (cache hit). Gadījumā, ja noticis keša trāpījums, procesors nekavējoties izlasa vai ieraksta datus keša rindā. Proporciju, kas parāda piekļuves, kuru rezultāti ir keša hiti, sauc par trāpījumu biežumu (hit rate), kas ir keša efektivitātes rādītājs.

> Gadījumā, ja nav keša trāpījums (cache miss), vairums kešu izvieto jaunu ieeju ar tagu (tag) „tikko nebija un notika kopēšana no galvenās atmiņas”. Gadījumā, ja atkārtojas pieprasījums pēc tiem pašiem datiem, jaunajai ieejai var piekārtot atsauci ar šo tagu, tāpat kā keša trāpījuma gadījumā. Miss ir lēni, jo tie pieprasa datus pārnest no galvenās atmiņas. Šī pārraide rada aizkavēšanos, jo galvenā atmiņa ir daudz lēnāka nekā keša atmiņa.


## Tests

<!-- ## Atrodi pareizos vārdus te: -->

<!-- - [Atrodi ar HPC saistītus  starptautiskus apzīmējumus.](../testi/test-2n#tests-2-12) --> -->


```spoiler {title: "Pašpārbaudes Jaurājums"}

:include-iframe: iframe/uzdevums.html {
    title: "Uzdevums 2.11",
  fit: false, 
  aspectRatio: "7:6",
  border: null,
}
```

# Superdatora darbības ātrums

> Ir vairāki izplatīti rādītāji superdatoru veiktspējas mērīšanai un to savstarpējai salīdzināšanai. Klasisks rādītājs ir peldošā komata darbību skaits, ko dators var izpildīt vienā sekundē (FLOP/s).

> **Ko nozīmē FLOP/s**? 
Peldošā komata skaitlis ir reāla skaitļa attēlojums datorā. Ja mēs vienā sekundē veicam vienu aprēķinu, piemēram, divu reālu skaitļu saskaitīšanu 2.1 + 4.3, tad tas ir vienāds ar vienu peldošā komata darbību sekundē (1 FLOP/s).

> Lai gan datori var strādāt arī ar veseliem skaitļiem, lielāko daļu zinātnisko problēmu matemātiski var atrisināt, izmantojot tikai reālos skaitļus. Šajā rādītājā iekļautās darbības ir aritmētiskās pamatoperācijas: saskaitīšana, atņemšana, reizināšana un dalīšana. Gadu gaitā FLOP/s ir kļuvis par vispāratzītu standartu superdatoru novērtēšanā.

Piemēram, ja dators var izpildīt
+ miljards (10<sup>9</sup>) FLOP/s, tā veiktspēja ir viens *Giga* FLOP/s (**G**FLOP/s),
+ vienu triljonu (10<sup>12</sup>) FLOP/s, tad - viens *Tera* FLOP/s (**T**FLOP/s),
+ vienu kvadriljonu jeb 10<sup>15</sup> FLOP/s, tad - viens *Peta* FLOP/s (**P**FLOP/s).

> **CPU kodola teorētisko skaitļošanas jaudu nosaka taktātrums un maksimālais peldošā komata darbību skaits, ko tas var veikt vienā taktī.** GPU teorētisko maksimālo veiktspēju aprēķina līdzīgi.

> Piemēram, ja klēpjdatora CPU kodola takts frekvence ir 3 GHz un tas var veikt 16 peldošā komata darbības, tad kopējā kodola maksimālā veiktspēja ir 48 GFLOP/s, jo

```latex
3 × 10^9 \>[1/sec] × 16 \>FLOP = 48 \>[GFLOP/sec]
```

> Visa superdatora teorētisko maksimālo veiktspēju iegūst, reizinot tā CPU un GPU teorētisko maksimālo veiktspēju ar sistēmā izmantoto komponentu (CPU un GPU) skaitu.

> Termins *teorētiskais* norāda uz to, ka šo skaitļošanas jaudu parasti nevar sasniegt reālos aprēķinos. Lai centrālais procesors varētu aprēķināt 2.1 + 4.3, tam no atmiņas ir jāiegūst divi skaitļi, un pēc tam rezultāts jāsaglabā atmiņā. Tas nenotiek uzreiz, tāpēc praksē skaitļošanas ātrumu nosaka ne tikai CPU tīrā skaitļošanas jauda, bet arī tas, cik ātri CPU var piekļūt atmiņai.

> Superdatoros viena mezgla centrālajam procesoram var būt nepieciešams piekļūt datiem arī citā mezglā. Tādējādi datu pārraides ātrums starp mezgliem arī var ierobežot praktisko veiktspēju. Turklāt reālajām lietojumprogrammām arī ir jālasa un jāieraksta dati diskā, kas nozīmē, ka ievades/izvades ātrums vai datu pārsūtīšana starp procesoriem un datu krātuvi var vēl vairāk ierobežot veiktspēju.

| Darbības sekundē | Zinātniskais apzīmējums | Metriskais prefikss | Mērvienība |
|--------------|:-----:|:-----:|-----------:|
| 1 000 |  10<sup>3</sup> |        kilo | KFLOP/s |
| 1 000 000  |  10<sup>6</sup> |          mega | MFLOP/s |
| 1 000 000 000  |  10<sup>9</sup> |          giga | GFLOP/s |
| 1 000 000 000 000  |  10<sup>12</sup> |          tera | TFLOP/s |
| 1 000 000 000 000 000  |  10<sup>15</sup> |          peta | PFLOP/s |
| 1 000 000 000 000 000 000  |  10<sup>18</sup> |          eksa | EFLOP/s |

## Tests
> Skaitļošanas klasterī ir 10 CPU kodoli. Katra kodola takts frekvence ir 4 GHz, un tas var veikt 18 peldošā komata darbības vienā taktī. Kāda ir skaitļošanas klastera teorētiskā maksimālā veiktspēja GFLOP/s?
Atbilde: 10 * (4*10^9 [1/s] * 18 [FLOP]) = 720 GFOP/s
