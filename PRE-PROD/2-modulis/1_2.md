---
title: Datora darbības principi
---

# Apzīmējumi un Modeļi

## Elementārs Datora Modelis

:include-image: pix/hpc-datora-modelis-w.png {anchorId: "datora-modelis", collapsed: false,  align:"center", scale: 0.7, title: "Datora Modelis - LV/EN", desktopOnly: true}

:include-image: pix/hpc-datora-modelis.png {anchorId: "datora-modelis", collapsed: false,  align:"center", fit: true, title: "Datora Modelis - LV", mobileOnly: true}


## Elementārs HPC Mezgla Modelis

> "MEZGLS" (eng. *Node*) ir funkcionāls iekārtu apvienojums,
kas nodrošina gan skaitļošanu, gan datu īstermiņa uzglabāšanu.

:include-image: pix/hpc-node-model-en-lv-w.png {title: "HPC mezgls / HPC node", fit: true, align: "center",  desktopOnly: true }


## HPC Klastera Modelis no Datu Skatu Punkta

> Kas ir HPC klasteris / HPC datoru kopa

:include-image: pix/hpc-cluster-lv-en-w.png {title: "HPC klasteris / HPC datoru kopa", fit: true, align: "left",  desktopOnly: true }

:include-image: pix/hpc-cluster-en-mob.png {title: "HPC cluster model", fit: true, align: "left",  mobileOnly: true }

:include-image: pix/hpc-cluster-lv-mob.png {title: "HPC klastera modelis / HPC datoru kopa", fit: true, align: "left",  mobileOnly: true }

<!-- <img src="https://github.com/viktorszagorskis/hpc-pamati/blob/main/pix/HPC-KLASTERA-MODELIS.png?raw=true" alt="HPC Klastera Modelis" width="800"/> -->

## HPC Klatera Anatomija

:include-image: pix/hpc-cluster-anatomy-en-w.png {title: "HPC klastera Anatomija - EN", scale: 0.8, align: "center",  desktopOnly: false }

:include-image: pix/hpc-cluster-anatomy-lv-w.png {title: "HPC klastera Anatomija - LV", scale: 0.8, align: "center",  desktopOnly: true }

:include-image: pix/hpc-cluster-anatomy-lv-mob.png {title: "HPC klastera Anatomija - LV", fit: true, align: "left",  mobileOnly: true }


>  Jautajumi seko ...


- Kas ir [RAM](https://lv.wikipedia.org/wiki/Br%C4%ABvpiek%C4%BCuves_atmi%C5%86a) ?
- Kas ir [CACHE](https://en.wikipedia.org/wiki/CPU_cache) ?
- Kas ir SDD?
- Kas ir SHARED MEMORY?
- Kas ir [NAS](https://www.seagate.com/gb/en/blog/what-is-nas-master-ti) ?



### Par Sīkatmiņu jeb Kešatmiņu (eng. CACHE) (LV versija)

> Procesora kešatmiņa (angļu: cache) ir atmiņas veids, ko izmanto datora procesors, lai samazinātu vidējo piekļūšanas laiku operatīvajai atmiņai (RAM). Kešatmiņa jeb kešs ir maza, ātra atmiņa, kas glabā tās datu atmiņu kopijas no galvenās atmiņas, kuras datorprogrammas izmanto visbiežāk. Kamēr vien lielākā daļa piekļuves notiks kešam, nevis galvenajai atmiņai, atmiņas piekļūšanas vidējais latentums (latency) būs tuvāks keša latentumam, nevis galvenās atmiņas latentumam, kas vairumā gadījumu nodrošina būtisku aparatūras darbības paātrināšanos.

> Kad procesors vēlas nolasīt vai ierakstīt galvenajā atmiņā, tas vispirms pārbauda, vai šī atmiņas kopija jau neatrodas kešā. To panāk, salīdzinot atmiņas atrašanās adresi ar visiem tagiem kešā, kas varētu saturēt šo adresi. Ja procesors atrod, ka atmiņas kopija ir kešā, saka, ka ir noticis keša trāpījums (cache hit). Gadījumā, ja noticis keša trāpījums, procesors nekavējoties izlasa vai ieraksta datus keša rindā. Proporciju, kas parāda piekļuves, kuru rezultāti ir keša hiti, sauc par trāpījumu biežumu (hit rate), kas ir keša efektivitātes rādītājs.

> Gadījumā, ja nav keša trāpījums (cache miss), vairums kešu izvieto jaunu ieeju ar tagu (tag) „tikko nebija un notika kopēšana no galvenās atmiņas”. Gadījumā, ja atkārtojas pieprasījums pēc tiem pašiem datiem, jaunajai ieejai var piekārtot atsauci ar šo tagu, tāpat kā keša trāpījuma gadījumā. Miss ir lēni, jo tie pieprasa datus pārnest no galvenās atmiņas. Šī pārraide rada aizkavēšanos, jo galvenā atmiņa ir daudz lēnāka nekā keša atmiņa.


## Tests

<!-- ## Atrodi pareizos vārdus te: -->

<!-- - [Atrodi ar HPC saistītus  starptautiskus apzīmējumus.](../testi/test-2n#tests-2-12) --> -->


```spoiler {title: "Pašpārbaudes Jaurājums"}

:include-iframe: iframe/uzdevums.html {
    title: "Uzdevums 2.11",
  fit: false, 
  aspectRatio: "7:6",
  border: null,
}
```

# Superdatora darbības ātrums

> Ir vairāki izplatīti rādītāji superdatoru veiktspējas mērīšanai un to savstarpējai salīdzināšanai. Klasisks rādītājs ir peldošā komata darbību skaits, ko dators var izpildīt vienā sekundē (FLOP/s).

> **Ko nozīmē FLOP/s**? 
Peldošā komata skaitlis ir reāla skaitļa attēlojums datorā. Ja mēs vienā sekundē veicam vienu aprēķinu, piemēram, divu reālu skaitļu saskaitīšanu 2.1 + 4.3, tad tas ir vienāds ar vienu peldošā komata darbību sekundē (1 FLOP/s).

> Lai gan datori var strādāt arī ar veseliem skaitļiem, lielāko daļu zinātnisko problēmu matemātiski var atrisināt, izmantojot tikai reālos skaitļus. Šajā rādītājā iekļautās darbības ir aritmētiskās pamatoperācijas: saskaitīšana, atņemšana, reizināšana un dalīšana. Gadu gaitā FLOP/s ir kļuvis par vispāratzītu standartu superdatoru novērtēšanā.

Piemēram, ja dators var izpildīt
+ miljards (10<sup>9</sup>) FLOP/s, tā veiktspēja ir viens *Giga* FLOP/s (**G**FLOP/s),
+ vienu triljonu (10<sup>12</sup>) FLOP/s, tad - viens *Tera* FLOP/s (**T**FLOP/s),
+ vienu kvadriljonu jeb 10<sup>15</sup> FLOP/s, tad - viens *Peta* FLOP/s (**P**FLOP/s).

> **CPU kodola teorētisko skaitļošanas jaudu nosaka taktātrums un maksimālais peldošā komata darbību skaits, ko tas var veikt vienā taktī.** GPU teorētisko maksimālo veiktspēju aprēķina līdzīgi.

> Piemēram, ja klēpjdatora CPU kodola takts frekvence ir 3 GHz un tas var veikt 16 peldošā komata darbības, tad kopējā kodola maksimālā veiktspēja ir 48 GFLOP/s, jo

```latex
3 × 10^9 \>[1/sec] × 16 \>FLOP = 48 \>[GFLOP/sec]
```

> Visa superdatora teorētisko maksimālo veiktspēju iegūst, reizinot tā CPU un GPU teorētisko maksimālo veiktspēju ar sistēmā izmantoto komponentu (CPU un GPU) skaitu.

> Termins *teorētiskais* norāda uz to, ka šo skaitļošanas jaudu parasti nevar sasniegt reālos aprēķinos. Lai centrālais procesors varētu aprēķināt 2.1 + 4.3, tam no atmiņas ir jāiegūst divi skaitļi, un pēc tam rezultāts jāsaglabā atmiņā. Tas nenotiek uzreiz, tāpēc praksē skaitļošanas ātrumu nosaka ne tikai CPU tīrā skaitļošanas jauda, bet arī tas, cik ātri CPU var piekļūt atmiņai.

> Superdatoros viena mezgla centrālajam procesoram var būt nepieciešams piekļūt datiem arī citā mezglā. Tādējādi datu pārraides ātrums starp mezgliem arī var ierobežot praktisko veiktspēju. Turklāt reālajām lietojumprogrammām arī ir jālasa un jāieraksta dati diskā, kas nozīmē, ka ievades/izvades ātrums vai datu pārsūtīšana starp procesoriem un datu krātuvi var vēl vairāk ierobežot veiktspēju.

| Darbības sekundē | Zinātniskais apzīmējums | Metriskais prefikss | Mērvienība |
|--------------|:-----:|:-----:|-----------:|
| 1 000 |  10<sup>3</sup> |        kilo | KFLOP/s |
| 1 000 000  |  10<sup>6</sup> |          mega | MFLOP/s |
| 1 000 000 000  |  10<sup>9</sup> |          giga | GFLOP/s |
| 1 000 000 000 000  |  10<sup>12</sup> |          tera | TFLOP/s |
| 1 000 000 000 000 000  |  10<sup>15</sup> |          peta | PFLOP/s |
| 1 000 000 000 000 000 000  |  10<sup>18</sup> |          eksa | EFLOP/s |

## Tests
> Skaitļošanas klasterī ir 10 CPU kodoli. Katra kodola takts frekvence ir 4 GHz, un tas var veikt 18 peldošā komata darbības vienā taktī. Kāda ir skaitļošanas klastera teorētiskā maksimālā veiktspēja GFLOP/s?
Atbilde: 10 * (4*10^9 [1/s] * 18 [FLOP]) = 720 GFOP/s
